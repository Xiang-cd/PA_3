# Cricuit 报告



## 解题思路：

1. 蛮力将所有电路转化为unsigned long后依次遍历比较, 在复杂度上是不可行的。
2. 对于异或操作, 如果希望得到尽可能大的值, 则希望尽量高的位是不同的, 而如果通过高位进行分类删选, 则可以在开始的时候就去掉大量的节点, 无需全部比较。由这个想法, 可以构建一棵二叉树来存储比较窗口中的所有节点。
3. 二叉树的构建原则如下, 从电路的第一位开始, 如果该位是0(低电平), 则走向树的左孩子, 否则走向树的右孩子。则每个电路都是深度为64的叶子节点, 并且不同的电路必然位于不同的叶子节点。
4. 在树的存储方式上使用链表的形式而非数组形式, 因为树的深度很深, 但是实际存在的叶节点却很少, 用链表形式节省空间。
5. 树的节点插入和树的构建一致, 按照每位的高低电平情况进行左右方向的选择, 如果路径上为空则`new`相应的新节点, 直到叶子节点。
6. 树的节点删除操作, 先找到相应的叶节点, 然后从叶节点开始递归向上: 如果该节点的父亲只有一个孩子(这个孩子就是该节点), 则对父亲也进行相同的递归操作(如果父亲也是独子, 继续向上), 总体的效果为删除叶节点所在的最长单链, 同样是为了节省空间, 同时也为了下次搜索时提高效率, 只需判断节点是否存在, 无需额外标记。
7. 给定树的节点, 给定一个电路, 如果希望在树中找到与这个电路最匹配的节点, 则按照如下方法: 从电路的第一位开始, 如果该位为高电平, 则在树中走向左节点, 如果左节点不存在, 则被迫走右节点, 反之同理。可知按照此方法寻路得到的结果必然是从高位优先匹配不同的电平的结果, 得到的结果即最优结果。
8. 因为可能存在重复节点, 但每个几点的序号不一致, 在匹配时优先选择选择序号小的, 则需要在叶子节点中构建链表, 记录当前重复节点中的各个序号值, 插入重复节点时, 在链表后加入当前序号, 删除时删除链表的第一个序号, 当没有序号时, 向上递归删除节点。
9. 在判断节点时添加特判条件, 如果match节点的序号和当前匹配的节点序号一致(即自己和自己匹配, 只有在整个树只有一个叶节点时出现), 则取下一个序号, 而非当前序号。

## 复杂度分析

电路数量为n, 匹配窗口大小为m, 一般认为n>>m。

### 时间复杂度:

每次滑动窗口, 都需要进行一次插入, 一次查找, (查找后)删除, 一次匹配, 而每次操作的深度都不超过64, 64为常数, 则时间复杂度为O(n)。

### 空间复杂度:

本题具体实现采用了将所有输入转为unsigned long后存入数组的方法, 空间为O(n), 构建的树大小不超过64*m, 空间复杂度为O(m), 总体空间复杂度为O(m+n)。

如果仅仅储存窗口中的输入, 不将所有输入保存, 总体空间复杂度可以降到O(m)。

## 其他说明:

参考了习题课和往年习题课的课件, 在节点末端链表的实现细节方面和计04袁桢淏进行了讨论。

感谢助教和老师的辛苦付出~

