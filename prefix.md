# prefix 报告



## 解题思路：

利用kmp算法中的next数组。

1. next数组的意义是: next[i]表示最长的真前缀L, 使得该前缀L是i的一个后缀。
2. 对于某个前缀x, x本身一定是自己的一个前缀, 如果next[x]存在, 这意味着next[x]在x中额外出现过一次, 如果next[next[x]]存在, 这意味着这个串也额外在x中出现过一次, 可知x的前缀在x中额外出现的次数就是不断取next的次数(next 序列的长度。对于每个前缀, 前缀本身的原位出现只计算在每个next序列的首元素中, 这也意味着每个next 序列的长度至少为1。
3. 考察每个前缀x, 其原位出现记录在自己的next序列中的首位, 而其后的出现必然是因为成为某个前缀y的后缀, 即使某个前缀y的next序列的成员, 而这个y在后续z中的额外出现都会将x再次加入z的next 序列中。对于每个前缀x, 计算的次数没有遗漏, 也没有重复, 正确性得以保证。
4. next序列表现出可以利用递归的性质, 则可以进行如下算法的设计:
   1. 开辟next数组, 表示最长真前缀是该串后缀的结尾位置, 开辟len数组,表示该前缀next序列的长度
   2. `next[0] = -1 ; len[0] = 1`
   3. 线性扫描目标串, 不断求取每个前缀的next[i]和len[i], 具体分为几类, 以下用代码加注释表示

```c++
for (int i = 1; i < 20000001; ++i) {
  if (!(s[i] >= 'a' and s[i] <= 'z'))break;
    if (s[nxt[i - 1] + 1] == s[i]) { //如果前一个串的next串s的后一个字母恰好和s[i]相等, 则说明next[i]的正好是s加上后一个字母
      nxt[i] = nxt[i - 1] + 1; // 记录next
      len[i] = len[nxt[i]] + 1; // next序列的长度是next[i]的next序列的长度加1
    } else {
      l j = nxt[i - 1];
      while (j != -1) { // 如果最后一个字母s[i]不能和最大的s[next[i-1]+1] 匹配,也可能和较小的s[next[i-1]+1] 匹配, 通过while 循环遍历
        if (s[j + 1] == s[i]) {
          nxt[i] = j + 1;
          len[i] = len[nxt[i]] + 1;
          break;
        }
        j = nxt[j];
      }
      if (j == -1) {
        if (s[i] == s[0]) {// 如果都不能匹配, s[i]也可能和s[0]匹配
          nxt[i] = 0;
          len[i] = 2;
        } else {  //如果都不匹配, 则就是初始值
          len[i] = 1;
          nxt[i] = -1;
        }
      }
    }
  ans += (long long) len[i]; // 答案是所有序列长度的综合
}
```



## 算法复杂度

串长度为n

### 时间复杂度:

每次求取next[i], 可能耗费O(len[next[i-1]])的时间, 也可能耗费O(1)的时间。

考虑前后三次求值next[i-1], next[i] , next[i], 注重考察len[i]的变化, 如果len[i] = len[i-1] +1, 则根据分类可知, 在求next[i] 是O(1)的操作, 如果len[i] < len[i-1], 则可知在求next[i] 经过了O(len[i-1]-len[i])的操作(while的循环次数), 并且对于求next[i+1] 时, 不会超过O(len[i])的操作。

则根据上面发现的微观现象, 可知对于求next[i], 操作数不会超过\| len[i-1] - len[i] \| , 而len值的上升是定步长的, 每次最多上升1, 下降量可以任意, 但不超过len[i], 总的上升次数不超过n, 从而总的下降量也不超过n。

所以算法的复杂度为O(n)。

### 空间复杂度:

需要next数组和len数组进行信息的存储, 空间复杂度为O(n)。



## 其他说明:

参考了习题课和往年习题课的课件。

感谢助教和老师的辛苦付出~

